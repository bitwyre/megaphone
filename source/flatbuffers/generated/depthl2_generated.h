// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEPTHL2_BITWYRE_FLATBUFFERS_DEPTHL2_H_
#define FLATBUFFERS_GENERATED_DEPTHL2_BITWYRE_FLATBUFFERS_DEPTHL2_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Bitwyre {
namespace Flatbuffers {
namespace Depthl2 {

struct AskPrice;

struct BidPrice;

struct Data;
struct DataBuilder;

struct DepthEvent;
struct DepthEventBuilder;

struct DepthEventMessage;
struct DepthEventMessageBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) AskPrice FLATBUFFERS_FINAL_CLASS {
 private:
  double price_;
  double qty_;

 public:
  struct Traits;
  AskPrice()
      : price_(0),
        qty_(0) {
  }
  AskPrice(double _price, double _qty)
      : price_(::flatbuffers::EndianScalar(_price)),
        qty_(::flatbuffers::EndianScalar(_qty)) {
  }
  double price() const {
    return ::flatbuffers::EndianScalar(price_);
  }
  double qty() const {
    return ::flatbuffers::EndianScalar(qty_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return price();
    else if constexpr (Index == 1) return qty();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(AskPrice, 16);

struct AskPrice::Traits {
  using type = AskPrice;
  static constexpr auto name = "AskPrice";
  static constexpr auto fully_qualified_name = "Bitwyre.Flatbuffers.Depthl2.AskPrice";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "price",
    "qty"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) BidPrice FLATBUFFERS_FINAL_CLASS {
 private:
  double price_;
  double qty_;

 public:
  struct Traits;
  BidPrice()
      : price_(0),
        qty_(0) {
  }
  BidPrice(double _price, double _qty)
      : price_(::flatbuffers::EndianScalar(_price)),
        qty_(::flatbuffers::EndianScalar(_qty)) {
  }
  double price() const {
    return ::flatbuffers::EndianScalar(price_);
  }
  double qty() const {
    return ::flatbuffers::EndianScalar(qty_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return price();
    else if constexpr (Index == 1) return qty();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(BidPrice, 16);

struct BidPrice::Traits {
  using type = BidPrice;
  static constexpr auto name = "BidPrice";
  static constexpr auto fully_qualified_name = "Bitwyre.Flatbuffers.Depthl2.BidPrice";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "price",
    "qty"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

struct Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASKS = 4,
    VT_BIDS = 6
  };
  const ::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::AskPrice *> *asks() const {
    return GetPointer<const ::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::AskPrice *> *>(VT_ASKS);
  }
  const ::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::BidPrice *> *bids() const {
    return GetPointer<const ::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::BidPrice *> *>(VT_BIDS);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return asks();
    else if constexpr (Index == 1) return bids();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           verifier.EndTable();
  }
};

struct DataBuilder {
  typedef Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_asks(::flatbuffers::Offset<::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::AskPrice *>> asks) {
    fbb_.AddOffset(Data::VT_ASKS, asks);
  }
  void add_bids(::flatbuffers::Offset<::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::BidPrice *>> bids) {
    fbb_.AddOffset(Data::VT_BIDS, bids);
  }
  explicit DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Data> CreateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::AskPrice *>> asks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Bitwyre::Flatbuffers::Depthl2::BidPrice *>> bids = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_bids(bids);
  builder_.add_asks(asks);
  return builder_.Finish();
}

struct Data::Traits {
  using type = Data;
  static auto constexpr Create = CreateData;
  static constexpr auto name = "Data";
  static constexpr auto fully_qualified_name = "Bitwyre.Flatbuffers.Depthl2.Data";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "asks",
    "bids"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<Data> CreateDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Bitwyre::Flatbuffers::Depthl2::AskPrice> *asks = nullptr,
    const std::vector<Bitwyre::Flatbuffers::Depthl2::BidPrice> *bids = nullptr) {
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<Bitwyre::Flatbuffers::Depthl2::AskPrice>(*asks) : 0;
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<Bitwyre::Flatbuffers::Depthl2::BidPrice>(*bids) : 0;
  return Bitwyre::Flatbuffers::Depthl2::CreateData(
      _fbb,
      asks__,
      bids__);
}

struct DepthEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthEventBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENT = 4,
    VT_TIMESTAMP = 6,
    VT_DEPTH = 8
  };
  const ::flatbuffers::String *instrument() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTRUMENT);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const Bitwyre::Flatbuffers::Depthl2::Data *depth() const {
    return GetPointer<const Bitwyre::Flatbuffers::Depthl2::Data *>(VT_DEPTH);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return instrument();
    else if constexpr (Index == 1) return timestamp();
    else if constexpr (Index == 2) return depth();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUMENT) &&
           verifier.VerifyString(instrument()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_DEPTH) &&
           verifier.VerifyTable(depth()) &&
           verifier.EndTable();
  }
};

struct DepthEventBuilder {
  typedef DepthEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instrument(::flatbuffers::Offset<::flatbuffers::String> instrument) {
    fbb_.AddOffset(DepthEvent::VT_INSTRUMENT, instrument);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(DepthEvent::VT_TIMESTAMP, timestamp, 0);
  }
  void add_depth(::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::Data> depth) {
    fbb_.AddOffset(DepthEvent::VT_DEPTH, depth);
  }
  explicit DepthEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthEvent> CreateDepthEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> instrument = 0,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::Data> depth = 0) {
  DepthEventBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_depth(depth);
  builder_.add_instrument(instrument);
  return builder_.Finish();
}

struct DepthEvent::Traits {
  using type = DepthEvent;
  static auto constexpr Create = CreateDepthEvent;
  static constexpr auto name = "DepthEvent";
  static constexpr auto fully_qualified_name = "Bitwyre.Flatbuffers.Depthl2.DepthEvent";
  static constexpr size_t fields_number = 3;
  static constexpr std::array<const char *, fields_number> field_names = {
    "instrument",
    "timestamp",
    "depth"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DepthEvent> CreateDepthEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *instrument = nullptr,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::Data> depth = 0) {
  auto instrument__ = instrument ? _fbb.CreateString(instrument) : 0;
  return Bitwyre::Flatbuffers::Depthl2::CreateDepthEvent(
      _fbb,
      instrument__,
      timestamp,
      depth);
}

struct DepthEventMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthEventMessageBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_EVENT = 4,
    VT_LEVEL = 6
  };
  const Bitwyre::Flatbuffers::Depthl2::DepthEvent *depth_event() const {
    return GetPointer<const Bitwyre::Flatbuffers::Depthl2::DepthEvent *>(VT_DEPTH_EVENT);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return depth_event();
    else if constexpr (Index == 1) return level();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEPTH_EVENT) &&
           verifier.VerifyTable(depth_event()) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           verifier.EndTable();
  }
};

struct DepthEventMessageBuilder {
  typedef DepthEventMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_depth_event(::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::DepthEvent> depth_event) {
    fbb_.AddOffset(DepthEventMessage::VT_DEPTH_EVENT, depth_event);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(DepthEventMessage::VT_LEVEL, level, 0);
  }
  explicit DepthEventMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthEventMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthEventMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthEventMessage> CreateDepthEventMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::DepthEvent> depth_event = 0,
    uint8_t level = 0) {
  DepthEventMessageBuilder builder_(_fbb);
  builder_.add_depth_event(depth_event);
  builder_.add_level(level);
  return builder_.Finish();
}

struct DepthEventMessage::Traits {
  using type = DepthEventMessage;
  static auto constexpr Create = CreateDepthEventMessage;
  static constexpr auto name = "DepthEventMessage";
  static constexpr auto fully_qualified_name = "Bitwyre.Flatbuffers.Depthl2.DepthEventMessage";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "depth_event",
    "level"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline const Bitwyre::Flatbuffers::Depthl2::DepthEventMessage *GetDepthEventMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage>(buf);
}

inline const Bitwyre::Flatbuffers::Depthl2::DepthEventMessage *GetSizePrefixedDepthEventMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage>(buf);
}

inline bool VerifyDepthEventMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage>(nullptr);
}

inline bool VerifySizePrefixedDepthEventMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage>(nullptr);
}

inline void FinishDepthEventMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDepthEventMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Bitwyre::Flatbuffers::Depthl2::DepthEventMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Depthl2
}  // namespace Flatbuffers
}  // namespace Bitwyre

#endif  // FLATBUFFERS_GENERATED_DEPTHL2_BITWYRE_FLATBUFFERS_DEPTHL2_H_
